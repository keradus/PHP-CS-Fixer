A lot of needed fixers are similar one to another. Would be great to have generic code that could be reused for similar fixers.

3.2 [DONE]
----------
[DONE] `php_unit_no_expectation_annotation`: anontations `@expectedException @expectedExceptionCode @expectedExceptionMessage` into respective methods
[done]    + integration test of `php_unit_no_expectation_annotation`+`php_unit_expectation`
[done]    + integration test of `php_unit_no_expectation_annotation`+`no_empty_phpdoc`
[done]    + add ruleset for 3.2

4.3 [DONE]
----------
[DONE] `php_unit_no_expectation_annotation`: like 3.2 but with `@expectedExceptionMessageRegExp`
[done]    + add ruleset for 4.3

5.2 [DONE]
----------
[DONE] `php_unit_expectation`: `setExpectedException` -> `expectException` + `expectExceptionMessage` + `expectExceptionCode`

5.6 [DONE]
----------
[DONE] `php_unit_expectation`: `setExpectedExceptionRegExp` -> `expectException` + `expectExceptionMessageRegExp` + `expectExceptionCode`
[DONE] `php_unit_dedicate_assert`:
    is_dir      -> assertDirectoryExists / assertDirectoryNotExists
    is_readable -> assertIsReadable / assertNotIsReadable
    is_writable -> assertIsWritable / assertNotIsWritable

5.7 [awaits]
------------
Similar to `PHPUnit_Framework_TestCase` we already have fixer for (this branch), we need to:
`PHPUnit_Framework_Assert` -> `PHPUnit\Framework\Assert`
`PHPUnit_Framework_BaseTestListener` -> `PHPUnit\Framework\BaseTestListener`
`PHPUnit_Framework_TestListener` -> `PHPUnit\Framework\TestListener`
Probably best way of doing this if via new `General***` fixer

6.0 [awaits]
------------
whole code is namespaced now: `PHPUnit_**_*_*` -> `PHPUnit\**\*\*`
    while changing `Foo\Bar\Baz` -> `Xxx`
        when changing from `Foo\Bar\Baz as Dupa` -> no need to check if `Xxx` is also imported, as only alias name will be used
        when changing from `Foo\Bar\Baz` -> we need to check if `Xxx` is also imported, and if so, we shall produce `Xxx as Baz` (as we know Baz is possible to use)
        comma-separated import, group imports
        when a class is already in current namespace
        what about partial imports ? (also, when no import, yet current namespace)
        CT::T_NAMESPACE_OPERATOR
        update not only `use Foo\Bar`, but also `namespace Foo\Bar`
        `use function`
        `use const`
        FQCN: rename `use FOO` (non-trait), `namespace Foo`
        rename `new Foo`, `Foo::`, `foo()`, `class Foo`, `use Foo` (trait)
        aliasing
        during replacement, ignore function and const, eg `->TestCase()`, `::TestCase`
        `Foo\Bar\Baz\Qux` means:
            - `new Foo\Bar\Baz\Qux()`
            - `namespace Foo\Bar\Baz\Qux`
            - `use Foo\Bar\Baz\Qux`
            - `use Foo\Bar\Baz; new Baz\Qux()` (ref-1)
            - `namespace Foo\Bar; new Baz\Qux();` (ref-2)
            - `namespace Foo\Bar; new namespace\Baz\Qux();` (ref-3)
        what about comments? eg `@param ...` ?

        STEPS:
            - check `// @TODO FRS: collecting, maybe useful`
            - all configured translations are FQCN
            - create emptu non-FQCN list
            - update namespace using FQCN, during that update non-FQCN (vide ref-2, ref-3)
            - if no namespace, copy FQCN into non-FQCN
            - update imports using FQCN, during that update non-FQCN translations (vide ref-1)
            - use both, FQCN and non-FQCN lists to fix rest of code (non-namespace declaration and non-imports)


config [awaits]
---------------
add @PHPUnit...
drop drop `general_phpdoc_annotation_remove`